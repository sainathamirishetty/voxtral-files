<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Minutes of Meeting</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }
        .header h1 { font-size: 2.5em; margin-bottom: 10px; }
        .back-btn {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid white;
            padding: 8px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        .back-btn:hover {
            background: white;
            color: #667eea;
        }
        .content { padding: 30px; }
        .section {
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        .section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        .form-group { margin-bottom: 15px; }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }
        input, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
        }
        input:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        .radio-group {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .radio-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: normal;
            cursor: pointer;
        }
        .radio-group input[type="radio"] {
            width: auto;
            cursor: pointer;
        }
        button {
            padding: 12px 25px;
            font-size: 15px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
        }
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary { background: #667eea; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-warning { background: #ffc107; color: #333; }
        .status-box {
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            height: 150px;
            overflow-y: auto;
            font-size: 13px;
        }
        .status-box p { margin: 3px 0; }
        .result-item {
    background: white;
    border: 2px solid #667eea;
    border-radius: 10px;
    padding: 25px;  /* Increased from 20px */
    margin: 15px 0;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e0e0;
        }
        .result-header h3 {
            color: #667eea;
            margin: 0;
            font-size: 1.4em;
        }
        .result-content {
            line-height: 1.8;
            color: #333;
            font-size: 15px;
            margin-top: 5px;
        }
        .result-content h4 {
            color: #667eea;
            margin-top: 20px;
            margin-bottom: 12px;
            font-size: 1.2em;
            font-weight: 600;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e0e0;
        }
        .result-content p {
            margin-bottom: 15px;
            text-align: justify;
        }
        .result-content ul, .result-content ol {
            margin-left: 25px;
            margin-bottom: 15px;
            margin-top: 10px;
        }
        .result-content li {
            margin-bottom: 8px;
            line-height: 1.6;
        }
        .recording-indicator {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #ffc107;
        }
        .recording-indicator.active { display: flex; }
        .pulse {
            width: 12px;
            height: 12px;
            background: #dc3545;
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
        .timer {
            font-weight: 600;
            color: #dc3545;
            font-size: 1.1em;
        }
        .chunk-timer {
            font-weight: 600;
            color: #667eea;
            font-size: 0.9em;
            margin-left: auto;
        }
        .button-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        .mode-info {
            background: #e3f2fd;
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #2196f3;
            font-size: 13px;
            color: #1565c0;
        }
        .library-status {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <button class="back-btn" onclick="goBack()">‚Üê Back</button>
            <h1>üìã Minutes of Meeting</h1>
        </div>

        <div class="content">
            <!-- Library Status -->
            <div class="library-status">
                ‚úì Using built-in RTF format - No external libraries needed! Works 100% offline.
            </div>

            <!-- Meeting Info -->
            <div class="section">
                <h2>üìã Meeting Information</h2>
                <div class="form-group">
                    <label>Date:</label>
                    <input type="date" id="date">
                </div>
                <div class="form-group">
                    <label>Time:</label>
                    <input type="time" id="time">
                </div>
                <div class="form-group">
                    <label>Venue:</label>
                    <input type="text" id="venue" placeholder="Enter meeting venue">
                </div>
                <div class="form-group">
                    <label>Agenda:</label>
                    <input type="text" id="agenda" placeholder="Enter meeting agenda">
                </div>
                <div class="form-group">
                    <label>Additional Context:</label>
                    <textarea id="context" rows="3" placeholder="Enter any additional context"></textarea>
                </div>
            </div>

            <!-- Processing Mode -->
            <div class="section">
                <h2>‚öôÔ∏è Processing Mode</h2>
                <div class="mode-info" id="modeInfo">
                    üìÑ Summary: 5min auto-chunks | ‚úÖ Action Points: 5min auto-chunks
                </div>
                <div class="form-group">
                    <label>Select Mode:</label>
                    <div class="radio-group">
                        <label>
                            <input type="radio" name="mode" value="Summary" id="modeSummary" checked>
                            Summary
                        </label>
                        <label>
                            <input type="radio" name="mode" value="Action Points" id="modeActionPoints">
                            Action Points
                        </label>
                    </div>
                </div>
                <div class="form-group" id="summaryLengthGroup">
                    <label>Summary Length:</label>
                    <div class="radio-group">
                        <label>
                            <input type="radio" name="summaryLength" value="Short" id="lengthShort">
                            Short
                        </label>
                        <label>
                            <input type="radio" name="summaryLength" value="Medium" id="lengthMedium" checked>
                            Medium
                        </label>
                        <label>
                            <input type="radio" name="summaryLength" value="Long" id="lengthLong">
                            Long
                        </label>
                    </div>
                </div>
            </div>

            <!-- Recording Controls -->
            <div class="section">
                <h2>üé§ Recording Controls</h2>
                <div class="recording-indicator" id="recIndicator">
                    <div class="pulse"></div>
                    <span>Recording in progress...</span>
                    <span class="timer" id="timer">00:00:00</span>
                    <span class="chunk-timer" id="chunkTimer"></span>
                </div>

                <div class="button-row">
                    <button class="btn-primary" id="startBtn" onclick="startRec()">Start Meeting</button>
                    <button class="btn-warning" id="pauseBtn" onclick="pauseRec()" disabled>Pause</button>
                    <button class="btn-danger" id="stopBtn" onclick="endMeeting()" disabled>End Meeting</button>
                </div>

                <div class="button-row">
                    <button class="btn-info" onclick="uploadFile()">Upload Audio File</button>
                    <button class="btn-primary" onclick="genGlobalSummary()">Generate Global Summary</button>
                    <button class="btn-success" onclick="saveResults()">Save Results (.doc)</button>
                </div>

                <input type="file" id="fileInput" accept=".wav,.webm,.mp3,.m4a,.ogg" style="display:none" onchange="handleFile(event)">
            </div>

            <!-- Status -->
            <div class="section">
                <h2>üìä Status</h2>
                <div class="status-box" id="status"></div>
            </div>

            <!-- Results -->
            <div class="section" id="resultsSection" style="display:none;">
                <h2>üìù Results</h2>
                <div id="results"></div>
            </div>
        </div>
    </div>

    <script>
        let mediaRecorder = null;
        let audioChunks = [];
        let isRecording = false;
        let isPaused = false;
        let startTime = null;
        let timerInterval = null;
        let chunkTimerInterval = null;
        let pausedTime = 0;
        let pauseStartTime = null;
        let serverUrl = 'http://127.0.0.1:8000';
        let allResults = [];
        let currentMode = 'Summary';
        let currentMimeType = 'audio/webm';
        let lastChunkTime = null;
        let autoChunkInterval = null;
        let audioContext = null;
        let scriptProcessor = null;
        let audioInput = null;
        let bufferData = [];
        let chunkCounter = 0;
        let meetingStartTime = null;
        let mediaStreamRef = null;

        function goBack() {
            window.location.href = '/';
        }

        document.addEventListener('DOMContentLoaded', () => {
            const today = new Date();
            document.getElementById('date').valueAsDate = today;
            document.getElementById('time').value = today.toTimeString().slice(0, 5);

            document.querySelectorAll('input[name="mode"]').forEach(radio => {
                radio.addEventListener('change', handleModeChange);
            });

            handleModeChange();
            checkServerSilently();
            log('‚úì System ready - No external libraries needed');
        });

        async function checkServerSilently() {
            try {
                const response = await fetch(`${serverUrl}/health`);
                const data = await response.json();
                if (data.status === 'healthy' && data.model_loaded) {
                    log('‚úî Server connected and ready');
                } else {
                    log('‚ö† Server connected but model loading');
                }
            } catch (error) {
                log('‚úó Cannot connect to server: ' + error.message);
            }
        }

        function handleModeChange() {
            const mode = document.querySelector('input[name="mode"]:checked').value;
            const summaryLengthGroup = document.getElementById('summaryLengthGroup');
            const modeInfo = document.getElementById('modeInfo');

            summaryLengthGroup.style.display = mode === 'Summary' ? 'block' : 'none';

            if (mode === 'Summary') {
                modeInfo.textContent = 'üìÑ Summary mode: Auto-processes every 5 minutes. Creates new result each time.';
            } else {
                modeInfo.textContent = '‚úÖ Action Points mode: Auto-processes every 5 minutes. Creates new result each time.';
            }

            if (isRecording && mode !== currentMode) {
                log(`üîÑ Mode changed: ${currentMode} ‚Üí ${mode}`);
                processModeSwitch(currentMode, mode);
            }
        }

        async function startRec() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                mediaStreamRef = stream;

                isRecording = false;
                isPaused = false;
                startTime = null;
                pausedTime = 0;
                pauseStartTime = null;
                audioChunks = [];
                bufferData = [];
                currentMode = document.querySelector('input[name="mode"]:checked').value;
                currentMimeType = 'audio/wav';

                const audioTrack = stream.getAudioTracks()[0];
                const settings = audioTrack.getSettings();
                const micSampleRate = settings.sampleRate || 48000;

                log(`üé§ Microphone sample rate: ${micSampleRate}Hz`);

                audioContext = new (window.AudioContext || window.webkitAudioContext)({});
                audioInput = audioContext.createMediaStreamSource(stream);

                const bufferSize = 4096;
                scriptProcessor = audioContext.createScriptProcessor(bufferSize, 1, 1);

                scriptProcessor.onaudioprocess = function(e) {
                    if (!isPaused && isRecording) {
                        const inputData = e.inputBuffer.getChannelData(0);
                        const buffer = new Float32Array(inputData);
                        bufferData.push(buffer);
                    }
                };

                audioInput.connect(scriptProcessor);
                scriptProcessor.connect(audioContext.destination);

                isRecording = true;
                isPaused = false;
                startTime = Date.now();
                lastChunkTime = Date.now();
                pausedTime = 0;
                chunkCounter = 0;
                meetingStartTime = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);

                startTimer();
                startChunkTimer();
                startAutoChunking();

                document.getElementById('recIndicator').classList.add('active');
                document.getElementById('startBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('stopBtn').disabled = false;

                log('‚úî Meeting started - Mode: ' + currentMode + ` (Recording at ${micSampleRate}Hz)`);
            } catch (error) {
                log('‚úó Error starting recording: ' + error.message);
                alert('Error accessing microphone: ' + error.message);
            }
        }

        function getChunkDuration(mode) {
            return 300000;
        }

        function startAutoChunking() {
            stopAutoChunking();
            const duration = getChunkDuration(currentMode);

            autoChunkInterval = setInterval(() => {
                if (isRecording && !isPaused) {
                    log(`‚è∞ Auto-processing ${duration/1000}-second ${currentMode} chunk`);
                    processCurrentChunk(currentMode);
                    lastChunkTime = Date.now();
                }
            }, duration);
        }

        function stopAutoChunking() {
            if (autoChunkInterval) {
                clearInterval(autoChunkInterval);
                autoChunkInterval = null;
            }
        }

        function startChunkTimer() {
            chunkTimerInterval = setInterval(() => {
                if (isRecording && !isPaused) {
                    const elapsed = Math.floor((Date.now() - lastChunkTime) / 1000);
                    const chunkDuration = getChunkDuration(currentMode) / 1000;
                    const remaining = chunkDuration - elapsed;

                    if (remaining >= 0) {
                        const minutes = Math.floor(remaining / 60);
                        const seconds = remaining % 60;
                        const timeStr = minutes > 0
                            ? `${minutes}m ${seconds}s`
                            : `${seconds}s`;
                        document.getElementById('chunkTimer').textContent = `Next chunk in: ${timeStr}`;
                    }
                } else {
                    document.getElementById('chunkTimer').textContent = '';
                }
            }, 1000);
        }

        function pauseRec() {
            if (!isRecording) {
                log('‚ö†Ô∏è No active recording to pause');
                return;
            }

            if (isPaused) {
                isPaused = false;
                if (pauseStartTime) {
                    pausedTime += (Date.now() - pauseStartTime);
                    pauseStartTime = null;
                }
                document.getElementById('pauseBtn').textContent = 'Pause';
                log('‚úî Recording resumed');
            } else {
                isPaused = true;
                pauseStartTime = Date.now();
                document.getElementById('pauseBtn').textContent = 'Resume';
                log('‚è∏ Recording paused');
            }
        }

        async function processModeSwitch(oldMode, newMode) {
            log(`üì§ Processing accumulated audio with mode: ${oldMode}`);
            await processCurrentChunk(oldMode);
            currentMode = newMode;
            lastChunkTime = Date.now();
            log(`‚úÖ Switched to ${newMode} mode - Timer reset`);
            startAutoChunking();
        }

        async function processCurrentChunk(mode) {
            if (bufferData.length === 0) {
                log('‚ö†Ô∏è No audio to process');
                return;
            }

            const summaryLength = document.querySelector('input[name="summaryLength"]:checked')?.value || 'Medium';
            log(`üì§ Processing chunk with mode: ${mode}`);

            const chunksToProcess = [...bufferData];
            bufferData = [];

            let totalLength = 0;
            for (const chunk of chunksToProcess) {
                totalLength += chunk.length;
            }

            const mergedData = new Float32Array(totalLength);
            let offset = 0;
            for (const chunk of chunksToProcess) {
                mergedData.set(chunk, offset);
                offset += chunk.length;
            }

            const wavBlob = encodeWAV(mergedData, audioContext.sampleRate, 16000);
            const duration = (mergedData.length / audioContext.sampleRate).toFixed(2);
            log(`üìä WAV audio size: ${(wavBlob.size / 1024).toFixed(2)} KB, Duration: ${duration}s`);

            chunkCounter++;
            log('üì§ Sending WAV audio to server');
            await sendAudioToServer(wavBlob, mode, summaryLength);
        }

        async function processCurrentChunkAndWait(mode) {
            if (bufferData.length === 0) {
                log('‚ö†Ô∏è No audio to process');
                return;
            }

            const summaryLength = document.querySelector('input[name="summaryLength"]:checked')?.value || 'Medium';
            log(`üì§ Processing final chunk with mode: ${mode}`);

            const chunksToProcess = [...bufferData];
            bufferData = [];

            let totalLength = 0;
            for (const chunk of chunksToProcess) {
                totalLength += chunk.length;
            }

            const mergedData = new Float32Array(totalLength);
            let offset = 0;
            for (const chunk of chunksToProcess) {
                mergedData.set(chunk, offset);
                offset += chunk.length;
            }

            const wavBlob = encodeWAV(mergedData, audioContext.sampleRate, 16000);
            const duration = (mergedData.length / audioContext.sampleRate).toFixed(2);
            log(`üìä WAV audio size: ${(wavBlob.size / 1024).toFixed(2)} KB, Duration: ${duration}s`);

            chunkCounter++;
            log('üì§ Sending final WAV audio to server and waiting...');
            await sendAudioToServerAndWait(wavBlob, mode, summaryLength);
        }

        async function endMeeting() {
            if (!isRecording) {
                log('‚ö†Ô∏è No active meeting to end');
                return;
            }

            log('üõë Ending meeting...');
            document.getElementById('stopBtn').disabled = true;
            log('‚è≥ Please wait - processing final audio chunk...');

            stopTimer();
            stopAutoChunking();
            if (chunkTimerInterval) {
                clearInterval(chunkTimerInterval);
                chunkTimerInterval = null;
            }

            isRecording = false;
            isPaused = false;

            try {
                if (bufferData.length > 0) {
                    const mode = document.querySelector('input[name="mode"]:checked').value;
                    log('üì§ Processing final audio chunk...');
                    await processCurrentChunkAndWait(mode);
                    log('‚úÖ Final chunk processing complete!');
                } else {
                    log('‚ÑπÔ∏è No remaining audio to process');
                }
            } catch (err) {
                log('‚úó Error while processing final chunk: ' + err.message);
            }

            try {
                if (scriptProcessor) {
                    scriptProcessor.onaudioprocess = null;
                    try { scriptProcessor.disconnect(); } catch(e){}
                    scriptProcessor = null;
                    log('‚úî Audio processing stopped');
                }

                if (audioInput) {
                    try { audioInput.disconnect(); } catch(e){}
                    audioInput = null;
                    log('‚úî Audio input disconnected');
                }

                if (mediaStreamRef) {
                    try {
                        mediaStreamRef.getTracks().forEach(track => {
                            try { track.stop(); } catch(e){}
                            log(`‚úî Stopped ${track.kind} track`);
                        });
                    } catch (e) {
                        log('‚ö†Ô∏è Error stopping media tracks: ' + e.message);
                    }
                    mediaStreamRef = null;
                }

                if (audioContext && audioContext.state !== 'closed') {
                    try {
                        await audioContext.close();
                        audioContext = null;
                        log('‚úî AudioContext closed');
                    } catch (e) {
                        log('‚ö†Ô∏è Error closing AudioContext: ' + e.message);
                    }
                }
            } catch (error) {
                log('‚ö†Ô∏è Error cleaning up audio: ' + error.message);
            }

            document.getElementById('recIndicator').classList.remove('active');
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('pauseBtn').textContent = 'Pause';
            document.getElementById('timer').textContent = '00:00:00';
            document.getElementById('chunkTimer').textContent = '';

            bufferData = [];
            chunkCounter = 0;
            meetingStartTime = null;
            isPaused = false;
            pausedTime = 0;
            pauseStartTime = null;
            startTime = null;
            lastChunkTime = null;

            log('‚úÖ Meeting ended successfully!');
        }

        function uploadFile() {
            document.getElementById('fileInput').click();
        }

        async function handleFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const mode = document.querySelector('input[name="mode"]:checked').value;
            const summaryLength = document.querySelector('input[name="summaryLength"]:checked')?.value || 'Medium';

            log(`üì§ Uploading file: ${file.name} with mode: ${mode}`);
            await sendAudioToServer(file, mode, summaryLength);

            event.target.value = '';
        }

        async function sendAudioToServer(audioBlob, mode, summaryLength) {
            const formData = new FormData();
            const filename = `chunk_${Date.now()}.wav`;

            formData.append('file', audioBlob, filename);
            formData.append('mode', mode);
            if (mode === 'Summary') {
                formData.append('summary_length', summaryLength);
            }

            try {
                log(`‚è≥ Uploading WAV to server... (Mode: ${mode}${mode === 'Summary' ? `, Length: ${summaryLength}` : ''})`);

                const response = await fetch(`${serverUrl}/process_audio`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Server request failed');
                }

                const data = await response.json();
                log(`‚úî Job created: ${data.job_id.substring(0, 8)}... (${data.mode})`);

                pollJobStatus(data.job_id, mode);

            } catch (error) {
                log('‚úó Error sending audio: ' + error.message);
                alert('Error uploading audio: ' + error.message);
            }
        }

        async function sendAudioToServerAndWait(audioBlob, mode, summaryLength) {
            const formData = new FormData();
            const filename = `chunk_${Date.now()}.wav`;

            formData.append('file', audioBlob, filename);
            formData.append('mode', mode);
            if (mode === 'Summary') {
                formData.append('summary_length', summaryLength);
            }

            try {
                log(`‚è≥ Uploading final WAV to server...`);

                const response = await fetch(`${serverUrl}/process_audio`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Server request failed');
                }

                const data = await response.json();
                log(`‚úî Final job created: ${data.job_id.substring(0, 8)}...`);

                await waitForJobCompletion(data.job_id, mode);

            } catch (error) {
                log('‚úó Error sending final audio: ' + error.message);
                alert('Error uploading final audio: ' + error.message);
            }
        }

        async function waitForJobCompletion(jobId, originalMode) {
            return new Promise(async (resolve, reject) => {
                const maxAttempts = 180;
                let attempts = 0;

                const checkStatus = async () => {
                    attempts++;

                    try {
                        const response = await fetch(`${serverUrl}/job_status/${jobId}`);

                        if (!response.ok) {
                            throw new Error('Failed to get job status');
                        }

                        const data = await response.json();

                        if (data.status === 'completed') {
                            log(`‚úÖ Final job ${jobId.substring(0, 8)}... completed!`);
                            displayResult(data, originalMode);
                            resolve();
                        } else if (data.status === 'error') {
                            log(`‚úó Final job ${jobId.substring(0, 8)}... failed: ${data.error}`);
                            reject(new Error('Processing failed: ' + data.error));
                        } else if (attempts >= maxAttempts) {
                            log(`‚è± Final job ${jobId.substring(0, 8)}... timed out`);
                            reject(new Error('Processing timed out'));
                        } else {
                            if (attempts % 5 === 0) {
                                log(`‚è≥ Processing final chunk... (${attempts}s)`);
                            }
                            setTimeout(checkStatus, 1000);
                        }
                    } catch (error) {
                        log('‚úó Error checking final job status: ' + error.message);
                        reject(error);
                    }
                };

                checkStatus();
            });
        }

        async function pollJobStatus(jobId, originalMode) {
            const maxAttempts = 180;
            let attempts = 0;
            let completed = false;

            const pollInterval = setInterval(async () => {
                if (completed) return;

                attempts++;

                try {
                    const response = await fetch(`${serverUrl}/job_status/${jobId}`);

                    if (!response.ok) {
                        throw new Error('Failed to get job status');
                    }

                    const data = await response.json();

                    if (completed) return;

                    if (data.status === 'completed') {
                        completed = true;
                        clearInterval(pollInterval);
                        log(`‚úî Job ${jobId.substring(0, 8)}... completed!`);
                        displayResult(data, originalMode);
                    } else if (data.status === 'error') {
                        completed = true;
                        clearInterval(pollInterval);
                        log(`‚úó Job ${jobId.substring(0, 8)}... failed: ${data.error}`);
                        alert('Processing failed: ' + data.error);
                    } else if (attempts >= maxAttempts) {
                        completed = true;
                        clearInterval(pollInterval);
                        log(`‚è± Job ${jobId.substring(0, 8)}... timed out`);
                        alert('Processing timed out. Please try again.');
                    } else if (attempts % 5 === 0) {
                        log(`‚è≥ Processing... (${attempts}s)`);
                    }
                } catch (error) {
                    if (!completed) {
                        completed = true;
                        clearInterval(pollInterval);
                        log('‚úó Error polling job status: ' + error.message);
                    }
                }
            }, 1000);
        }

        function displayResult(jobData, originalMode) {
            document.getElementById('resultsSection').style.display = 'block';
            const resultsContainer = document.getElementById('results');

            const resultDiv = document.createElement('div');
            resultDiv.className = 'result-item';

            const header = document.createElement('div');
            header.className = 'result-header';

            const title = document.createElement('h3');
            if (originalMode === 'Summary' && jobData.summary_length) {
                title.textContent = `Summary (${jobData.summary_length})`;
            } else if (originalMode === 'GLOBAL SUMMARY') {
                title.textContent = 'Global Summary';
            } else if (originalMode === 'Action Points') {
                title.textContent = 'Action Points';
            } else {
                title.textContent = originalMode;
            }

            header.appendChild(title);

            const content = document.createElement('div');
            content.className = 'result-content';

            const cleanText = jobData.result
                .replace(/\[SUMMARY[^\]]*\]\s*/g, '')
                .replace(/\[ACTION POINTS\]\s*/g, '')
                .replace(/\[GLOBAL SUMMARY\]\s*/g, '')
                .trim();

            content.innerHTML = formatTextToHTML(cleanText);

            resultDiv.appendChild(header);
            resultDiv.appendChild(content);

            resultsContainer.insertBefore(resultDiv, resultsContainer.firstChild);

            allResults.push({
                mode: originalMode,
                result: jobData.result,
                summary_length: jobData.summary_length || '',
                timestamp: new Date().toISOString()
            });

            resultDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function formatTextToHTML(text) {
            text = text
                .replace(/\*\*\*/g, '')
                .replace(/\*\*/g, '')
                .replace(/\*/g, '')
                .replace(/__|__/g, '')
                .replace(/\#\#\#/g, '')
                .replace(/\#\#/g, '')
                .replace(/\#/g, '')
                .replace(/~~(.+?)~~/g, '$1');

            let html = '';
            const lines = text.split('\n');
            let inParagraph = false;
            let inOrderedList = false;
            let inUnorderedList = false;

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();

                if (line === '') {
                    if (inParagraph) {
                        html += '</p>';
                        inParagraph = false;
                    }
                    if (inOrderedList) {
                        html += '</ol>';
                        inOrderedList = false;
                    }
                    if (inUnorderedList) {
                        html += '</ul>';
                        inUnorderedList = false;
                    }
                    continue;
                }

                const actionMatch = line.match(/^‚û§\s*(.+)/);
                if (actionMatch) {
                    if (inParagraph) html += '</p>';
                    if (inOrderedList) html += '</ol>';
                    if (inUnorderedList) html += '</ul>';
                    inParagraph = false;
                    inOrderedList = false;
                    inUnorderedList = false;
                    html += `<p style="margin-left:20px;color:#667eea;font-weight:600;">‚û§ ${actionMatch[1]}</p>`;
                    continue;
                }

                const numberedMatch = line.match(/^(\d+)[\.\)]\s+(.+)/);
                if (numberedMatch) {
                    if (inParagraph) {
                        html += '</p>';
                        inParagraph = false;
                    }
                    if (inUnorderedList) {
                        html += '</ul>';
                        inUnorderedList = false;
                    }
                    if (!inOrderedList) {
                        html += '<ol>';
                        inOrderedList = true;
                    }
                    html += `<li>${numberedMatch[2]}</li>`;
                    continue;
                }

                const bulletMatch = line.match(/^[-‚Ä¢]\s+(.+)/);
                if (bulletMatch) {
                    if (inParagraph) {
                        html += '</p>';
                        inParagraph = false;
                    }
                    if (inOrderedList) {
                        html += '</ol>';
                        inOrderedList = false;
                    }
                    if (!inUnorderedList) {
                        html += '<ul>';
                        inUnorderedList = true;
                    }
                    html += `<li>${bulletMatch[1]}</li>`;
                    continue;
                }

                if (line.match(/^[A-Z\s]{4,}:?\s*$/)) {
                    if (inParagraph) html += '</p>';
                    if (inOrderedList) html += '</ol>';
                    if (inUnorderedList) html += '</ul>';
                    inParagraph = false;
                    inOrderedList = false;
                    inUnorderedList = false;
                    html += `<h4>${line.replace(/:+$/, '')}</h4>`;
                    continue;
                }

                if (inOrderedList) {
                    html += '</ol>';
                    inOrderedList = false;
                }
                if (inUnorderedList) {
                    html += '</ul>';
                    inUnorderedList = false;
                }

                if (!inParagraph) {
                    html += '<p>';
                    inParagraph = true;
                } else {
                    html += ' ';
                }
                html += line;
            }

            if (inParagraph) html += '</p>';
            if (inOrderedList) html += '</ol>';
            if (inUnorderedList) html += '</ul>';

            return html;
        }

        async function genGlobalSummary() {
            if (allResults.length === 0) {
                log('‚ö†Ô∏è No results available for global summary');
                alert('No results available. Please process some audio first.');
                return;
            }

            log('‚è≥ Generating global summary...');

            try {
                const texts = allResults.map(r => r.result);

                const response = await fetch(`${serverUrl}/global_summary`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ texts: texts })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Failed to generate global summary');
                }

                const data = await response.json();

                displayResult({
                    mode: 'GLOBAL SUMMARY',
                    result: data.global_summary,
                    summary_length: ''
                }, 'GLOBAL SUMMARY');

                log('‚úî Global summary generated successfully!');

            } catch (error) {
                log('‚úó Error generating global summary: ' + error.message);
                alert('Error generating global summary: ' + error.message);
            }
        }

        function saveResults() {
            if (allResults.length === 0) {
                log('‚ö†Ô∏è No results to save');
                alert('No results to save. Please process some audio first.');
                return;
            }

            log('üíæ Preparing document...');

            try {
                const meetingDate = document.getElementById('date').value || 'Not specified';
                const meetingTime = document.getElementById('time').value || 'Not specified';
                const venue = document.getElementById('venue').value || 'Not specified';
                const agenda = document.getElementById('agenda').value || 'Not specified';
                const context = document.getElementById('context').value || 'None';

                // Create RTF content
                let rtfContent = '{\\rtf1\\ansi\\deff0\n';
                
                // Font table
                rtfContent += '{\\fonttbl{\\f0\\fswiss\\fcharset0 Arial;}{\\f1\\fmodern\\fcharset0 Courier New;}}\n';
                
                // Color table
                rtfContent += '{\\colortbl;\\red102\\green126\\blue234;\\red0\\green0\\blue0;\\red51\\green51\\blue51;}\n';
                
                // Title
                rtfContent += '\\qc\\fs36\\b MEETING MINUTES\\b0\\fs24\\par\\par\n';
                
                // Meeting Information Section
                rtfContent += '\\ql\\fs28\\b\\cf1 Meeting Information\\cf0\\b0\\fs24\\par\n';
                rtfContent += '\\par\n';
                
                // Meeting details table
                rtfContent += `\\b Date:\\b0  ${escapeRTF(meetingDate)}\\par\n`;
                rtfContent += `\\b Time:\\b0  ${escapeRTF(meetingTime)}\\par\n`;
                rtfContent += `\\b Venue:\\b0  ${escapeRTF(venue)}\\par\n`;
                rtfContent += `\\b Agenda:\\b0  ${escapeRTF(agenda)}\\par\n`;
                if (context && context !== 'None') {
                    rtfContent += `\\b Additional Context:\\b0  ${escapeRTF(context)}\\par\n`;
                }
                rtfContent += '\\par\\par\n';
                
                // Results Section
                rtfContent += '\\fs28\\b\\cf1 Results\\cf0\\b0\\fs24\\par\n';
                rtfContent += '\\par\n';
                
                // Process each result
                allResults.forEach((result, index) => {
                    let resultTitle = '';
                    if (result.mode === 'Summary' && result.summary_length) {
                        resultTitle = `${index + 1}. Summary (${result.summary_length})`;
                    } else if (result.mode === 'GLOBAL SUMMARY') {
                        resultTitle = `${index + 1}. Global Summary`;
                    } else if (result.mode === 'Action Points') {
                        resultTitle = `${index + 1}. Action Points`;
                    } else {
                        resultTitle = `${index + 1}. ${result.mode}`;
                    }
                    
                    rtfContent += `\\fs26\\b\\cf1 ${escapeRTF(resultTitle)}\\cf0\\b0\\fs24\\par\n`;
                    rtfContent += '\\par\n';
                    
                    const cleanText = result.result
                        .replace(/\[SUMMARY[^\]]*\]\s*/g, '')
                        .replace(/\[ACTION POINTS\]\s*/g, '')
                        .replace(/\[GLOBAL SUMMARY\]\s*/g, '')
                        .trim();
                    
                    rtfContent += convertTextToRTF(cleanText);
                    rtfContent += '\\par\\par\n';
                });
                
                // Footer
                rtfContent += '\\par\\par\n';
                rtfContent += `\\qc\\fs20 Generated on: ${new Date().toLocaleString()}\\par\n`;
                
                // Close RTF
                rtfContent += '}';
                
                // Create blob and download
                const blob = new Blob([rtfContent], { type: 'application/rtf' });
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `meeting_minutes_${timestamp}.doc`;
                a.click();
                URL.revokeObjectURL(url);

                log(`‚úî Results saved: meeting_minutes_${timestamp}.doc`);
                alert('Results saved successfully as Word document (.doc)!\n\nThe file can be opened in Microsoft Word, LibreOffice, or any word processor.');

            } catch (error) {
                log('‚úó Error saving results: ' + error.message);
                console.error('Full error:', error);
                alert('Error saving results: ' + error.message);
            }
        }

        function escapeRTF(text) {
    let result = '';
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const code = text.charCodeAt(i);

        if (char === '\\') {
            result += '\\\\';
        } else if (char === '{') {
            result += '\\{';
        } else if (char === '}') {
            result += '\\}';
        } else if (char === '\n') {
            result += '\\par\n';
        } else if (code > 127) {
            // Unicode character - encode as \uN?
            result += '\\u' + code + '?';
        } else {
            result += char;
        }
    }
    return result;
}

        function convertTextToRTF(text) {
            let rtf = '';
            
            // Clean markdown
            text = text
                .replace(/\*\*\*/g, '')
                .replace(/\*\*/g, '')
                .replace(/\*/g, '')
                .replace(/__|__/g, '')
                .replace(/\#\#\#/g, '')
                .replace(/\#\#/g, '')
                .replace(/\#/g, '');
            
            const lines = text.split('\n');
            
            for (let line of lines) {
                line = line.trim();
                
                if (line === '') {
                    rtf += '\\par\n';
                    continue;
                }
                
                // Action items (with arrow)
                const actionMatch = line.match(/^‚û§\s*(.+)/);
                if (actionMatch) {
                    rtf += `\\cf1\\b ‚û§ \\cf3\\b0 ${escapeRTF(actionMatch[1])}\\cf0\\par\n`;
                    continue;
                }
                
                // Numbered lists
                const numberedMatch = line.match(/^(\d+)[\.\)]\s+(.+)/);
                if (numberedMatch) {
                    rtf += `${numberedMatch[1]}. ${escapeRTF(numberedMatch[2])}\\par\n`;
                    continue;
                }
                
                // Bullet points
                const bulletMatch = line.match(/^[-‚Ä¢]\s+(.+)/);
                if (bulletMatch) {
                    rtf += `\\bullet  ${escapeRTF(bulletMatch[1])}\\par\n`;
                    continue;
                }
                
                // Section headers (ALL CAPS)
                if (line.match(/^[A-Z\s]{4,}:?\s*$/)) {
                    rtf += `\\par\\b\\cf1 ${escapeRTF(line.replace(/:+$/, ''))}\\cf0\\b0\\par\n`;
                    continue;
                }
                
                // Regular paragraph
                rtf += `${escapeRTF(line)}\\par\n`;
            }
            
            return rtf;
        }

        function startTimer() {
            timerInterval = setInterval(() => {
                if (!isPaused) {
                    const elapsed = Math.floor((Date.now() - startTime - pausedTime) / 1000);
                    const hours = Math.floor(elapsed / 3600);
                    const minutes = Math.floor((elapsed % 3600) / 60);
                    const seconds = elapsed % 60;

                    document.getElementById('timer').textContent =
                        `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function log(message) {
            const statusBox = document.getElementById('status');
            const p = document.createElement('p');
            const timestamp = new Date().toLocaleTimeString();
            p.textContent = `[${timestamp}] ${message}`;
            statusBox.appendChild(p);
            statusBox.scrollTop = statusBox.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        function encodeWAV(samples, inputSampleRate, outputSampleRate) {
            let resampledData;
            if (inputSampleRate !== outputSampleRate) {
                const ratio = inputSampleRate / outputSampleRate;
                const newLength = Math.round(samples.length / ratio);
                resampledData = new Float32Array(newLength);

                for (let i = 0; i < newLength; i++) {
                    const srcIndex = i * ratio;
                    const srcIndexFloor = Math.floor(srcIndex);
                    const srcIndexCeil = Math.min(srcIndexFloor + 1, samples.length - 1);
                    const t = srcIndex - srcIndexFloor;
                    resampledData[i] = samples[srcIndexFloor] * (1 - t) + samples[srcIndexCeil] * t;
                }
            } else {
                resampledData = samples;
            }

            const buffer = new ArrayBuffer(44 + resampledData.length * 2);
            const view = new DataView(buffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + resampledData.length * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, outputSampleRate, true);
            view.setUint32(28, outputSampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, resampledData.length * 2, true);

            floatTo16BitPCM(view, 44, resampledData);

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function floatTo16BitPCM(view, offset, input) {
            for (let i = 0; i < input.length; i++, offset += 2) {
                const s = Math.max(-1, Math.min(1, input[i]));
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }
        }
    </script>
</body>
</html>